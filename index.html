<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>聖誕訊號小遊戲</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    body {
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    /* 外層：決定圖片＋半圓的寬度 */
    .wrapper {
      position: relative;
      width: 90vw;
      max-width: 600px;
    }

    /* 上方聖誕圖片（換成你的檔名） */
    .main-image {
      width: 100%;
      height: auto;
      display: block;
    }

    /* 半圓指針疊在圖片裡，靠下方四分之一 */
    #overlay {
      position: absolute;
      left: 50%;
      bottom: 8%;           /* 想再往上就改大一點，例如 15% */
      transform: translateX(-50%);
      width: 100%;
      display: flex;
      justify-content: center;
      pointer-events: none;   /* 點擊交給 window */
    }

    #gameCanvas {
      width: 100%;           /* 幾乎跟圖片同寬 */
      max-width: 600px;
      height: auto;
    }

    /* 勝利影片的全螢幕遮罩 */
    #winOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;              /* 預設隱藏 */
      justify-content: center;
      align-items: center;
      z-index: 999;
    }

    #winOverlay video {
      width: 90vw;
      max-width: 480px;
      border-radius: 16px;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <!-- 換成你的聖誕手機圖檔名 -->
    <img src="BACKGROUND.png" alt="" class="main-image">

    <div id="overlay">
      <!-- 固定繪圖座標 600x300，視覺上會跟著上面的圖片縮放 -->
      <canvas id="gameCanvas" width="600" height="300"></canvas>
    </div>
  </div>

  <!-- 勝利時跳出的影片彈窗：請把 win.mp4 換成你的動畫檔名 -->
  <div id="winOverlay">
    <video id="winVideo" playsinline webkit-playsinline>
      <source src="win.mp4" type="video/mp4">
      <!-- 如果需要可以再加其他格式 -->
    </video>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const winOverlay = document.getElementById("winOverlay");
    const winVideo = document.getElementById("winVideo");
    let isVideoPlaying = false;

    // 幾乎佔滿寬度的半圓
    let cx = canvas.width / 2;
    let cy = canvas.height - 18;        // 靠近畫布底部
    let outerR = canvas.width * 0.38;   // 半圓半徑
    let innerR = outerR * 0.7;          // 半圓厚度

    const ARC_START = Math.PI;          // 180°（左邊）
    const ARC_END   = Math.PI * 2;      // 360°（右邊）
    const ARC_LEN   = ARC_END - ARC_START;

    let pointerAngle = ARC_START;
    let pointerDir = 1;
    const pointerSpeed = 3.0;

    let redStart = 0;
    let redEnd = 0;

    let isStopped = false;
    let lastTime = null;

    function resetRound() {
      // 隨機一段紅色中獎區域（很小）
      const redLen = ARC_LEN * (0.03 + Math.random() * 0.03);
      redStart = ARC_START + Math.random() * (ARC_LEN - redLen);
      redEnd = redStart + redLen;

      pointerAngle = ARC_START;
      pointerDir = 1;
      isStopped = false;
    }

    function drawArc() {
      // 白色半圓
      ctx.beginPath();
      ctx.arc(cx, cy, outerR, ARC_START, ARC_END, false);
      ctx.arc(cx, cy, innerR, ARC_END, ARC_START, true);
      ctx.closePath();
      ctx.fillStyle = "#ffffff";
      ctx.fill();

      // 紅色中獎區
      ctx.beginPath();
      ctx.arc(cx, cy, outerR, redStart, redEnd, false);
      ctx.arc(cx, cy, innerR, redEnd, redStart, true);
      ctx.closePath();
      ctx.fillStyle = "#ff4b4b";
      ctx.fill();
    }

    function drawPointer() {
      const midR = (outerR + innerR) / 2;
      const x = cx + midR * Math.cos(pointerAngle);
      const y = cy + midR * Math.sin(pointerAngle);

      ctx.strokeStyle = "#3ecfff";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(x, y);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(x, y, 8, 0, Math.PI * 2);
      ctx.fillStyle = "#3ecfff";
      ctx.fill();
    }

    function update(dt) {
      if (isStopped) return;

      pointerAngle += pointerDir * pointerSpeed * dt;

      if (pointerAngle > ARC_END) {
        pointerAngle = ARC_END;
        pointerDir = -1;
      } else if (pointerAngle < ARC_START) {
        pointerAngle = ARC_START;
        pointerDir = 1;
      }
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawArc();
      drawPointer();
    }

    function loop(timestamp) {
      if (lastTime == null) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      update(dt);
      render();
      requestAnimationFrame(loop);
    }

    function showWinVideo() {
      if (!winOverlay || !winVideo) {
        // 保險：如果沒 video element，就用 alert 當備援
        alert("✅ 恭喜！停在紅色範圍內！");
        resetRound();
        return;
      }
      isVideoPlaying = true;
      winOverlay.style.display = "flex";
      winVideo.currentTime = 0;

      const p = winVideo.play();
      if (p && p.catch) {
        p.catch(() => {
          // 如果自動播放被擋掉，就顯示控制列讓玩家手動播
          winVideo.setAttribute("controls", "controls");
        });
      }
    }

    function hideWinVideoAndReset() {
      isVideoPlaying = false;
      winOverlay.style.display = "none";
      winVideo.pause();
      resetRound();
    }

    function handleTap() {
      // 播動畫時不處理遊戲點擊
      if (isVideoPlaying) return;

      if (!isStopped) {
        isStopped = true;
        const hit = pointerAngle >= redStart && pointerAngle <= redEnd;
        if (hit) {
          // 中獎 → 播放影片
          showWinVideo();
        } else {
          // 沒中獎 → 保持原本的提示＋再點一次重來
          alert("❌ 差一點點，再試一次！");
        }
      } else {
        // 第二次點：沒中獎的情況下手動重置
        resetRound();
      }
    }

    // 全畫面都可以點
    window.addEventListener("click", handleTap);
    window.addEventListener("touchstart", (e) => {
      e.preventDefault();
      handleTap();
    }, { passive: false });

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        handleTap();
      }
    });

    // 影片播完自動關閉＋重開一局
    if (winVideo) {
      winVideo.addEventListener("ended", hideWinVideoAndReset);
    }

    // 點擊影片遮罩也可以關閉＋重開一局
    if (winOverlay) {
      winOverlay.addEventListener("click", hideWinVideoAndReset);
      winOverlay.addEventListener("touchstart", (e) => {
        e.preventDefault();
        hideWinVideoAndReset();
      }, { passive: false });
    }

    resetRound();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
