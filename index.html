
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>è–èª•è¨Šè™Ÿå°éŠæˆ²</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    body {
      /* æŠŠä¸‹é¢é€™å€‹ BACKGROUND.png æ›æˆä½ é‚£å¼µè–èª•æ‰‹æ©Ÿåœ–ç‰‡æª”å */
      background: #000 url('BACKGROUND.png') center center / cover no-repeat fixed;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
      overflow: hidden;
      position: relative;
    }
    #overlay {
      position: absolute;
      left: 50%;
      bottom: 20px;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ°åº•ä¸‹ç•«é¢ */
    }
    #gameCanvas {
      width: 80vw;
      max-width: 600px;
      height: auto;
    }
    #status {
      margin-top: 8px;
      padding: 4px 10px;
      background: rgba(0,0,0,0.55);
      border-radius: 999px;
      font-size: 14px;
      text-align: center;
      pointer-events: none;
    }
    @media (min-aspect-ratio: 3/4) {
      /* æ©«å‘è¢å¹•æ™‚è®“ç•«å¸ƒå°ä¸€é» */
      #gameCanvas {
        width: 50vw;
      }
    }
  </style>
</head>
<body>
  <!-- åº•ä¸‹é€™å¡Š overlay æ˜¯éŠæˆ²ç›¤ï¼Œç–Šåœ¨ä¸»ç•«é¢æœ€ä¸‹æ–¹ -->
  <div id="overlay">
    <canvas id="gameCanvas" width="600" height="260"></canvas>
    <div id="status">ğŸ‘† é»ä¸€ä¸‹è¢å¹•åœæ­¢æŒ‡é‡ï¼Œåœåœ¨ç´…è‰²ç¯„åœå°±ç®—ç²å‹ï¼</div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");

    const cx = canvas.width / 2;
    const cy = canvas.height + 80;  // åœ“å¿ƒåœ¨ç•«å¸ƒä¸‹æ–¹ï¼Œç•«å‡ºä¸Šç·£çš„å¼§
    const outerR = 260;
    const innerR = 220;

    const ARC_START = Math.PI * 0.2;
    const ARC_END   = Math.PI * 0.8;
    const ARC_LEN   = ARC_END - ARC_START;

    let pointerAngle = ARC_START;
    let pointerDir = 1;
    const pointerSpeed = 1.8;

    let redStart = 0;
    let redEnd = 0;

    let isStopped = false;  // false: è‡ªå‹•å·¦å³æ–æ“º, true: å·²åœæ­¢é¡¯ç¤ºçµæœ
    let lastTime = null;

    function resetRound() {
      const redLen = ARC_LEN * (0.18 + Math.random() * 0.14);
      redStart = ARC_START + Math.random() * (ARC_LEN - redLen);
      redEnd = redStart + redLen;

      pointerAngle = ARC_START;
      pointerDir = 1;
      isStopped = false;
      statusEl.textContent = "ğŸ‘† é»ä¸€ä¸‹è¢å¹•åœæ­¢æŒ‡é‡ï¼Œåœåœ¨ç´…è‰²ç¯„åœå°±ç®—ç²å‹ï¼";
    }

    function drawArc() {
      // ç™½è‰²å¼§å½¢
      ctx.beginPath();
      ctx.arc(cx, cy, outerR, ARC_START, ARC_END, false);
      ctx.arc(cx, cy, innerR, ARC_END, ARC_START, true);
      ctx.closePath();
      ctx.fillStyle = "#ffffff";
      ctx.fill();

      // ç´…è‰²ç¯„åœ
      ctx.beginPath();
      ctx.arc(cx, cy, outerR, redStart, redEnd, false);
      ctx.arc(cx, cy, innerR, redEnd, redStart, true);
      ctx.closePath();
      ctx.fillStyle = "#ff4b4b";
      ctx.fill();
    }

    function drawPointer() {
      const midR = (outerR + innerR) / 2;
      const x = cx + midR * Math.cos(pointerAngle);
      const y = cy + midR * Math.sin(pointerAngle);

      ctx.strokeStyle = "#3ecfff";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(cx, cy - 40);
      ctx.lineTo(x, y);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(x, y, 8, 0, Math.PI * 2);
      ctx.fillStyle = "#3ecfff";
      ctx.fill();
    }

    function update(dt) {
      if (isStopped) return;

      pointerAngle += pointerDir * pointerSpeed * dt;

      if (pointerAngle > ARC_END) {
        pointerAngle = ARC_END;
        pointerDir = -1;
      } else if (pointerAngle < ARC_START) {
        pointerAngle = ARC_START;
        pointerDir = 1;
      }
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawArc();
      drawPointer();
    }

    function loop(timestamp) {
      if (lastTime == null) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      update(dt);
      render();
      requestAnimationFrame(loop);
    }

    function handleTap() {
      if (!isStopped) {
        // ç¬¬ä¸€æ¬¡é»ï¼šåœæ­¢ä¸¦åˆ¤å®š
        isStopped = true;
        const hit = pointerAngle >= redStart && pointerAngle <= redEnd;
        if (hit) {
          statusEl.textContent = "âœ… æ­å–œï¼ä½ åœ¨ç´…è‰²å€åŸŸå…§åœæ­¢è¨Šè™Ÿï¼å†é»ä¸€æ¬¡è¢å¹•é‡æ–°é–‹å§‹ã€‚";
        } else {
          statusEl.textContent = "âŒ å·®ä¸€é»é»ï¼Œå†è©¦ä¸€æ¬¡ï¼å†é»ä¸€æ¬¡è¢å¹•é‡æ–°é–‹å§‹ã€‚";
        }
      } else {
        // ç¬¬äºŒæ¬¡é»ï¼šé‡æ–°é–‹å±€
        resetRound();
      }
    }

    // å…¨è¢å¹•éƒ½å¯ä»¥é»
    window.addEventListener("click", handleTap);
    window.addEventListener("touchstart", (e) => {
      e.preventDefault();
      handleTap();
    }, { passive: false });

    // å¯é¸ï¼šéµç›¤ç©ºç™½éµä¹Ÿèƒ½ç©
    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        handleTap();
      }
    });

    resetRound();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
